<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shader Playground</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: #F5F5F0;
      min-height: 100vh;
    }
    
    .app-layout {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    @media (min-width: 900px) {
      .app-layout {
        flex-direction: row;
      }
    }
    
    .preview-panel {
      background: #1a1a1a;
      padding: 20px;
      position: sticky;
      top: 0;
      z-index: 100;
      flex-shrink: 0;
    }
    
    @media (min-width: 900px) {
      .preview-panel {
        width: 55%;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
    }
    
    .preview-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 4px solid #333;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    .preview-header h1 {
      font-family: 'Playfair Display', serif;
      font-size: clamp(1.5rem, 3vw, 2.5rem);
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: -1px;
      color: #F5F5F0;
    }
    
    .preview-header h1 span {
      color: #E63946;
    }
    
    .preview-subtitle {
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: #666;
      margin-top: 5px;
    }
    
    .header-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .canvas-wrapper {
      position: relative;
      flex: 1;
      min-height: 250px;
    }
    
    @media (min-width: 900px) {
      .canvas-wrapper {
        min-height: 0;
      }
    }
    
    #shaderCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }
    
    .btn {
      font-family: 'Inter', sans-serif;
      font-size: 0.6rem;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      border: none;
      padding: 10px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .btn-primary {
      background: #E63946;
      color: #F5F5F0;
    }
    
    .btn-primary:hover {
      background: #ff4757;
    }
    
    .btn-secondary {
      background: #F5F5F0;
      color: #1a1a1a;
    }
    
    .btn-secondary:hover {
      background: #fff;
    }
    
    .btn-dark {
      background: #1a1a1a;
      color: #F5F5F0;
    }
    
    .btn-dark:hover {
      background: #E63946;
    }
    
    .btn-outline {
      background: transparent;
      color: #1a1a1a;
      border: 3px solid #1a1a1a;
    }
    
    .btn-outline.active {
      background: #1a1a1a;
      color: #F5F5F0;
    }
    
    .btn-recording {
      background: #E63946;
      color: #F5F5F0;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    /* Download Dropdown */
    .download-dropdown {
      position: relative;
    }
    
    .dropdown-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 5px;
      background: #F5F5F0;
      border: 4px solid #1a1a1a;
      min-width: 180px;
      z-index: 200;
      display: none;
    }
    
    .dropdown-menu.open {
      display: block;
    }
    
    .dropdown-item {
      display: block;
      width: 100%;
      padding: 12px 15px;
      font-family: 'Inter', sans-serif;
      font-size: 0.65rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: left;
      background: transparent;
      border: none;
      border-bottom: 2px solid #ddd;
      cursor: pointer;
      color: #1a1a1a;
      transition: all 0.2s ease;
    }
    
    .dropdown-item:last-child {
      border-bottom: none;
    }
    
    .dropdown-item:hover {
      background: #1a1a1a;
      color: #F5F5F0;
    }
    
    .dropdown-item-desc {
      display: block;
      font-size: 0.5rem;
      font-weight: 400;
      text-transform: none;
      letter-spacing: 0;
      color: #888;
      margin-top: 3px;
    }
    
    .dropdown-item:hover .dropdown-item-desc {
      color: #aaa;
    }
    
    /* Recording indicator */
    .recording-indicator {
      position: absolute;
      top: 15px;
      left: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(230, 57, 70, 0.95);
      color: #fff;
      padding: 8px 12px;
      font-size: 0.6rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      z-index: 50;
      display: none;
    }
    
    .recording-indicator.visible {
      display: flex;
    }
    
    .recording-dot {
      width: 10px;
      height: 10px;
      background: #fff;
      border-radius: 50%;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    .controls-panel {
      flex: 1;
      overflow-y: auto;
      padding: 25px 20px;
    }
    
    @media (min-width: 900px) {
      .controls-panel {
        width: 45%;
        height: 100vh;
        overflow-y: auto;
        padding: 30px;
      }
    }
    
    .section {
      margin-bottom: 25px;
    }
    
    .section-header {
      display: flex;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 15px;
      border-bottom: 4px solid #1a1a1a;
      padding-bottom: 10px;
    }
    
    .section-header h2 {
      font-family: 'Playfair Display', serif;
      font-size: 1.25rem;
      font-weight: 900;
      text-transform: uppercase;
    }
    
    .section-header span {
      font-family: 'Inter', sans-serif;
      font-size: 0.8rem;
      font-weight: 900;
      color: #E63946;
    }
    
    .effects-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }
    
    .effect-btn {
      font-family: 'Inter', sans-serif;
      font-size: 0.6rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: #1a1a1a;
      color: #F5F5F0;
      border: none;
      padding: 12px 8px;
      cursor: pointer;
      text-align: left;
      transition: all 0.2s ease;
    }
    
    .effect-btn.active {
      background: #E63946;
    }
    
    .effect-btn:hover:not(.active) {
      background: #333;
    }
    
    .palette-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-bottom: 12px;
    }
    
    .palette-btn {
      padding: 0;
      border: 3px solid transparent;
      cursor: pointer;
      background: transparent;
      transition: all 0.2s ease;
    }
    
    .palette-btn.active {
      border-color: #1a1a1a;
    }
    
    .palette-colors {
      display: flex;
      height: 28px;
    }
    
    .palette-colors div {
      flex: 1;
    }
    
    .palette-label {
      font-family: 'Inter', sans-serif;
      font-size: 0.5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 4px 2px;
      background: #1a1a1a;
      color: #F5F5F0;
      text-align: center;
    }
    
    .custom-colors {
      background: #1a1a1a;
      padding: 12px;
    }
    
    .custom-colors-label {
      font-size: 0.6rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: #F5F5F0;
      margin-bottom: 10px;
    }
    
    .color-pickers {
      display: flex;
      gap: 10px;
    }
    
    .color-picker-wrapper {
      flex: 1;
      text-align: center;
    }
    
    .color-picker-wrapper input {
      width: 100%;
      height: 40px;
      border: none;
      cursor: pointer;
      padding: 0;
    }
    
    .color-hex {
      font-family: monospace;
      font-size: 0.55rem;
      color: #666;
      margin-top: 5px;
      text-transform: uppercase;
    }
    
    .params-section {
      background: #FFD166;
      padding: 15px;
      margin-bottom: 25px;
    }
    
    .params-section .section-header {
      border-bottom-color: #1a1a1a;
    }
    
    .params-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
    }
    
    .param-control {
      margin-bottom: 0;
    }
    
    .param-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 6px;
    }
    
    .param-label {
      font-family: 'Playfair Display', serif;
      font-size: 0.85rem;
      font-weight: 700;
    }
    
    .param-value {
      font-family: 'Inter', sans-serif;
      font-size: 1rem;
      font-weight: 900;
    }
    
    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #1a1a1a;
      appearance: none;
      -webkit-appearance: none;
      cursor: pointer;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #E63946;
      cursor: pointer;
      border: none;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #E63946;
      cursor: pointer;
      border: none;
    }
    
    .fx-section {
      background: #1a1a1a;
      padding: 15px;
      margin-bottom: 25px;
    }
    
    .fx-section .section-header {
      border-bottom-color: #444;
    }
    
    .fx-section .section-header h2 {
      color: #F5F5F0;
    }
    
    .fx-section .section-header span {
      color: #FFD166;
    }
    
    .fx-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
    }
    
    .fx-control .param-header {
      margin-bottom: 6px;
    }
    
    .fx-control .param-label {
      color: #F5F5F0;
      font-family: 'Inter', sans-serif;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .fx-control .param-value {
      color: #FFD166;
      font-size: 0.9rem;
    }
    
    .fx-control input[type="range"] {
      background: #444;
    }
    
    .fx-description {
      font-size: 0.55rem;
      color: #666;
      margin-top: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .code-section {
      margin-bottom: 25px;
    }
    
    .code-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 15px;
      border-bottom: 4px solid #1a1a1a;
      padding-bottom: 10px;
    }
    
    .code-header-left {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }
    
    .code-header h2 {
      font-family: 'Playfair Display', serif;
      font-size: 1.25rem;
      font-weight: 900;
      text-transform: uppercase;
    }
    
    .code-header span {
      font-family: 'Inter', sans-serif;
      font-size: 0.8rem;
      font-weight: 900;
      color: #E63946;
    }
    
    #codeEditor {
      width: 100%;
      height: 200px;
      font-family: monospace;
      font-size: 0.7rem;
      background: #1a1a1a;
      color: #F5F5F0;
      border: none;
      padding: 12px;
      resize: vertical;
      line-height: 1.4;
      display: none;
    }
    
    #codeEditor:focus {
      outline: 3px solid #E63946;
    }
    
    #codeEditor.visible {
      display: block;
    }
    
    .error-display {
      background: #E63946;
      color: #F5F5F0;
      padding: 10px 12px;
      font-family: monospace;
      font-size: 0.65rem;
      margin-top: 8px;
      display: none;
    }
    
    .error-display.visible {
      display: block;
    }
    
    .compile-btn {
      margin-top: 10px;
      display: none;
    }
    
    .compile-btn.visible {
      display: inline-block;
    }
    
    .uniforms-section {
      background: #1a1a1a;
      color: #F5F5F0;
      padding: 15px;
    }
    
    .uniforms-section h3 {
      font-family: 'Playfair Display', serif;
      font-size: 1rem;
      font-weight: 900;
      text-transform: uppercase;
      margin-bottom: 12px;
    }
    
    .uniforms-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 8px;
      font-family: monospace;
      font-size: 0.6rem;
    }
    
    .uniforms-grid span {
      color: #E63946;
    }
    
    .uniforms-grid .color-uniform {
      color: #FFD166;
    }
    
    .uniforms-grid .fx-uniform {
      color: #06D6A0;
    }
    
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1a1a1a;
      color: #F5F5F0;
      padding: 12px 24px;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      z-index: 1000;
      transition: transform 0.3s ease;
    }
    
    .toast.visible {
      transform: translateX(-50%) translateY(0);
    }

    .controls-panel::-webkit-scrollbar {
      width: 8px;
    }
    
    .controls-panel::-webkit-scrollbar-track {
      background: #ddd;
    }
    
    .controls-panel::-webkit-scrollbar-thumb {
      background: #1a1a1a;
    }
    
    .controls-panel::-webkit-scrollbar-thumb:hover {
      background: #E63946;
    }
  </style>
</head>
<body>
  <div class="app-layout">
    <div class="preview-panel">
      <div class="preview-header">
        <div>
          <h1>Shader<span>Playground</span></h1>
          <p class="preview-subtitle">Create • Experiment • Visualize</p>
        </div>
        <div class="header-controls">
          <button id="playPauseBtn" class="btn btn-primary">Pause</button>
          <button id="resetBtn" class="btn btn-secondary">Reset</button>
          <div class="download-dropdown">
            <button id="downloadBtn" class="btn btn-secondary">Export ▼</button>
            <div id="downloadMenu" class="dropdown-menu">
              <button class="dropdown-item" id="downloadPNG">
                Screenshot
                <span class="dropdown-item-desc">Save current frame as PNG</span>
              </button>
              <button class="dropdown-item" id="downloadGIF">
                Record GIF
                <span class="dropdown-item-desc">Capture 4 second animation</span>
              </button>
              <button class="dropdown-item" id="downloadVideo">
                Record Video
                <span class="dropdown-item-desc">Capture as WebM video</span>
              </button>
              <button class="dropdown-item" id="downloadShader">
                Shader Code
                <span class="dropdown-item-desc">Export GLSL source</span>
              </button>
              <button class="dropdown-item" id="downloadSettings">
                Settings
                <span class="dropdown-item-desc">Export parameters as JSON</span>
              </button>
            </div>
          </div>
        </div>
      </div>
      <div class="canvas-wrapper">
        <canvas id="shaderCanvas"></canvas>
        <div id="recordingIndicator" class="recording-indicator">
          <div class="recording-dot"></div>
          <span id="recordingText">Recording...</span>
        </div>
      </div>
    </div>

    <div class="controls-panel">
      <section class="section">
        <div class="section-header">
          <h2>Effects</h2>
          <span>01</span>
        </div>
        <div id="effectsGrid" class="effects-grid"></div>
      </section>

      <section class="section">
        <div class="section-header">
          <h2>Palette</h2>
          <span>02</span>
        </div>
        <div id="paletteGrid" class="palette-grid"></div>
        <div class="custom-colors">
          <div class="custom-colors-label">Custom Colors</div>
          <div class="color-pickers">
            <div class="color-picker-wrapper">
              <input type="color" id="color1" value="#FF006E">
              <div class="color-hex" id="color1Hex">#FF006E</div>
            </div>
            <div class="color-picker-wrapper">
              <input type="color" id="color2" value="#8338EC">
              <div class="color-hex" id="color2Hex">#8338EC</div>
            </div>
            <div class="color-picker-wrapper">
              <input type="color" id="color3" value="#3A86FF">
              <div class="color-hex" id="color3Hex">#3A86FF</div>
            </div>
          </div>
        </div>
      </section>

      <section class="params-section">
        <div class="section-header">
          <h2>Parameters</h2>
          <span>03</span>
        </div>
        <div class="params-grid">
          <div class="param-control">
            <div class="param-header">
              <label class="param-label">Intensity</label>
              <span class="param-value" id="intensityValue">0.50</span>
            </div>
            <input type="range" id="intensity" min="0.1" max="1" step="0.01" value="0.5">
          </div>
          <div class="param-control">
            <div class="param-header">
              <label class="param-label">Speed</label>
              <span class="param-value" id="speedValue">0.50</span>
            </div>
            <input type="range" id="speed" min="0.1" max="2" step="0.01" value="0.5">
          </div>
          <div class="param-control">
            <div class="param-header">
              <label class="param-label">Scale</label>
              <span class="param-value" id="scaleValue">3.0</span>
            </div>
            <input type="range" id="scale" min="1" max="10" step="0.1" value="3">
          </div>
        </div>
      </section>

      <section class="fx-section">
        <div class="section-header">
          <h2>Post Effects</h2>
          <span>04</span>
        </div>
        <div class="fx-grid">
          <div class="fx-control">
            <div class="param-header">
              <label class="param-label">Halftone</label>
              <span class="param-value" id="halftoneValue">0.00</span>
            </div>
            <input type="range" id="halftone" min="0" max="1" step="0.01" value="0">
            <div class="fx-description">Retro dot pattern</div>
          </div>
          <div class="fx-control">
            <div class="param-header">
              <label class="param-label">Chromatic</label>
              <span class="param-value" id="chromaticValue">0.00</span>
            </div>
            <input type="range" id="chromatic" min="0" max="1" step="0.01" value="0">
            <div class="fx-description">RGB separation</div>
          </div>
          <div class="fx-control">
            <div class="param-header">
              <label class="param-label">Vortex</label>
              <span class="param-value" id="vortexValue">0.00</span>
            </div>
            <input type="range" id="vortex" min="0" max="1" step="0.01" value="0">
            <div class="fx-description">Swirl distortion</div>
          </div>
          <div class="fx-control">
            <div class="param-header">
              <label class="param-label">Pixelate</label>
              <span class="param-value" id="pixelateValue">0.00</span>
            </div>
            <input type="range" id="pixelate" min="0" max="1" step="0.01" value="0">
            <div class="fx-description">Retro mosaic</div>
          </div>
          <div class="fx-control">
            <div class="param-header">
              <label class="param-label">Glitch</label>
              <span class="param-value" id="glitchValue">0.00</span>
            </div>
            <input type="range" id="glitch" min="0" max="1" step="0.01" value="0">
            <div class="fx-description">Digital noise</div>
          </div>
          <div class="fx-control">
            <div class="param-header">
              <label class="param-label">Scanlines</label>
              <span class="param-value" id="scanlinesValue">0.00</span>
            </div>
            <input type="range" id="scanlines" min="0" max="1" step="0.01" value="0">
            <div class="fx-description">CRT monitor</div>
          </div>
        </div>
      </section>

      <section class="code-section">
        <div class="code-header">
          <div class="code-header-left">
            <h2>GLSL Code</h2>
            <span>05</span>
          </div>
          <button id="toggleCodeBtn" class="btn btn-outline">Show Editor</button>
        </div>
        <textarea id="codeEditor" spellcheck="false"></textarea>
        <div id="errorDisplay" class="error-display"></div>
        <button id="compileBtn" class="btn btn-dark compile-btn">Compile Shader</button>
      </section>

      <section class="uniforms-section">
        <h3>Available Uniforms</h3>
        <div class="uniforms-grid">
          <div><span>u_time</span> — secs</div>
          <div><span>u_resolution</span> — size</div>
          <div><span>u_intensity</span> — str</div>
          <div><span>u_speed</span> — tempo</div>
          <div><span>u_scale</span> — zoom</div>
          <div><span class="color-uniform">u_color1</span> — rgb</div>
          <div><span class="color-uniform">u_color2</span> — rgb</div>
          <div><span class="color-uniform">u_color3</span> — rgb</div>
          <div><span class="fx-uniform">u_halftone</span></div>
          <div><span class="fx-uniform">u_chromatic</span></div>
          <div><span class="fx-uniform">u_vortex</span></div>
          <div><span class="fx-uniform">u_pixelate</span></div>
          <div><span class="fx-uniform">u_glitch</span></div>
          <div><span class="fx-uniform">u_scanlines</span></div>
        </div>
      </section>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script>
    // Color Palettes
    const colorPalettes = {
      neon: { name: "Neon", colors: ['#FF006E', '#8338EC', '#3A86FF'] },
      sunset: { name: "Sunset", colors: ['#FF6B35', '#F7C59F', '#2E4057'] },
      arctic: { name: "Arctic", colors: ['#00F5D4', '#00BBF9', '#9B5DE5'] },
      fire: { name: "Fire", colors: ['#FFBE0B', '#FB5607', '#FF006E'] },
      forest: { name: "Forest", colors: ['#06D6A0', '#118AB2', '#073B4C'] },
      vapor: { name: "Vapor", colors: ['#F72585', '#7209B7', '#4CC9F0'] },
      mono: { name: "Mono", colors: ['#FFFFFF', '#888888', '#000000'] },
      candy: { name: "Candy", colors: ['#FF99C8', '#FCF6BD', '#A9DEF9'] }
    };

    const createShader = (baseLogic) => `precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform float u_intensity;
uniform float u_speed;
uniform float u_scale;
uniform vec3 u_color1;
uniform vec3 u_color2;
uniform vec3 u_color3;
uniform float u_halftone;
uniform float u_chromatic;
uniform float u_vortex;
uniform float u_pixelate;
uniform float u_glitch;
uniform float u_scanlines;

vec3 palette(float t) {
  t = fract(t);
  if (t < 0.5) {
    return mix(u_color1, u_color2, t * 2.0);
  } else {
    return mix(u_color2, u_color3, (t - 0.5) * 2.0);
  }
}

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

${baseLogic}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  vec2 originalUV = uv;
  
  if (u_pixelate > 0.01) {
    float pixels = mix(200.0, 20.0, u_pixelate);
    uv = floor(uv * pixels) / pixels;
  }
  
  if (u_vortex > 0.01) {
    vec2 center = vec2(0.5 + sin(u_time * u_speed * 0.5) * 0.2, 0.5 + cos(u_time * u_speed * 0.7) * 0.2);
    vec2 delta = uv - center;
    float dist = length(delta);
    float angle = atan(delta.y, delta.x);
    angle += u_vortex * exp(-dist * 3.0) * 5.0;
    uv = center + vec2(cos(angle), sin(angle)) * dist;
  }
  
  if (u_glitch > 0.01) {
    float glitchLine = step(0.99 - u_glitch * 0.1, random(vec2(floor(u_time * 20.0), floor(uv.y * 20.0))));
    uv.x += glitchLine * (random(vec2(u_time)) - 0.5) * u_glitch * 0.3;
  }
  
  vec3 col = getColor(uv);
  
  if (u_chromatic > 0.01) {
    vec2 center = vec2(0.5);
    vec2 dir = normalize(uv - center);
    float dist = length(uv - center);
    float aberration = u_chromatic * 0.03 * dist;
    col.r = getColor(uv + dir * aberration).r;
    col.b = getColor(uv - dir * aberration).b;
  }
  
  if (u_halftone > 0.01) {
    float dotSize = mix(8.0, 3.0, u_halftone);
    vec2 cellPos = floor(gl_FragCoord.xy / dotSize);
    vec2 cellCenter = (cellPos + 0.5) * dotSize;
    float dist = distance(gl_FragCoord.xy, cellCenter);
    float luminance = dot(col, vec3(0.299, 0.587, 0.114));
    float radius = luminance * dotSize * 0.6;
    float dot = smoothstep(radius + 1.0, radius - 1.0, dist);
    col = mix(col, col * dot, u_halftone);
  }
  
  if (u_scanlines > 0.01) {
    float scanline = sin(gl_FragCoord.y * 2.0) * 0.5 + 0.5;
    col *= 1.0 - u_scanlines * 0.3 * scanline;
    col *= 1.0 - u_scanlines * 0.1;
  }
  
  gl_FragColor = vec4(col, 1.0);
}`;

    const shaderPresets = {
      plasma: {
        name: "Plasma Wave",
        code: createShader(`
vec3 getColor(vec2 uv) {
  vec2 p = uv * u_scale - u_scale * 0.5;
  float t = u_time * u_speed;
  float v = sin(p.x * 10.0 + t);
  v += sin((p.y * 10.0 + t) * 0.5);
  v += sin((p.x * 10.0 + p.y * 10.0 + t) * 0.5);
  v += sin(length(p * 10.0) + t);
  v *= u_intensity * 0.25;
  return palette(v + t * 0.1);
}`)
      },
      tunnel: {
        name: "Infinite Tunnel",
        code: createShader(`
vec3 getColor(vec2 uv) {
  vec2 centered = uv - 0.5;
  float t = u_time * u_speed;
  float angle = atan(centered.y, centered.x);
  float radius = length(centered) * u_scale;
  float tunnel = 1.0 / max(radius, 0.01);
  float pattern = sin(tunnel * 5.0 - t * 3.0) * sin(angle * 8.0 + t);
  pattern *= u_intensity;
  vec3 col = palette(pattern * 0.5 + 0.5 + t * 0.1);
  col *= smoothstep(0.0, 0.3, radius);
  return col;
}`)
      },
      kaleidoscope: {
        name: "Kaleidoscope",
        code: createShader(`
#define PI 3.14159265359
vec3 getColor(vec2 uv) {
  vec2 centered = uv - 0.5;
  float t = u_time * u_speed;
  float angle = atan(centered.y, centered.x);
  float radius = length(centered) * u_scale;
  float segments = 8.0;
  angle = mod(angle, PI * 2.0 / segments);
  angle = abs(angle - PI / segments);
  vec2 p = vec2(cos(angle), sin(angle)) * radius;
  float pattern = 0.0;
  pattern += sin(p.x * 20.0 + t * 2.0) * u_intensity;
  pattern += sin(p.y * 20.0 - t * 1.5) * u_intensity;
  pattern += sin((p.x + p.y) * 15.0 + t) * u_intensity;
  return palette(pattern * 0.3 + t * 0.1);
}`)
      },
      fractalNoise: {
        name: "Fractal Flow",
        code: createShader(`
float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}
float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * (3.0 - 2.0 * f);
  return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
             mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
}
float fbm(vec2 p) {
  float v = 0.0, a = 0.5;
  for(int i = 0; i < 5; i++) { v += a * noise(p); p *= 2.0; a *= 0.5; }
  return v;
}
vec3 getColor(vec2 uv) {
  float t = u_time * u_speed;
  vec2 p = uv * u_scale;
  float n = fbm(p + fbm(p + fbm(p + t * 0.5)));
  n *= u_intensity * 2.0;
  return palette(n + t * 0.1);
}`)
      },
      ripples: {
        name: "Cosmic Ripples",
        code: createShader(`
vec3 getColor(vec2 uv) {
  vec2 centered = uv - 0.5;
  float t = u_time * u_speed;
  float d = length(centered) * u_scale;
  float wave = 0.0;
  for(float i = 1.0; i < 6.0; i++) {
    wave += sin(d * 20.0 / i - t * i * 0.5) / i;
  }
  wave *= u_intensity;
  float angle = atan(centered.y, centered.x);
  wave += sin(angle * 6.0 + t) * 0.3 * u_intensity;
  vec3 col = palette(wave * 0.5 + 0.5 + t * 0.05);
  col = mix(col, u_color1, smoothstep(0.4, 0.0, d / u_scale) * 0.5);
  return col;
}`)
      },
      warp: {
        name: "Space Warp",
        code: createShader(`
vec3 getColor(vec2 uv) {
  vec2 centered = uv - 0.5;
  float t = u_time * u_speed;
  float angle = atan(centered.y, centered.x);
  float radius = length(centered);
  angle += sin(radius * 10.0 * u_scale - t * 2.0) * u_intensity * 0.5;
  radius += cos(angle * 5.0 + t) * 0.1 * u_intensity;
  vec2 warped = vec2(cos(angle), sin(angle)) * radius;
  float grid = 0.0;
  grid += step(0.9, fract(warped.x * 10.0 + t));
  grid += step(0.9, fract(warped.y * 10.0 + t));
  vec3 bgCol = mix(u_color3, u_color2, radius);
  return mix(bgCol, u_color1, grid);
}`)
      },
      waves: {
        name: "Ocean Waves",
        code: createShader(`
vec3 getColor(vec2 uv) {
  float t = u_time * u_speed;
  float wave = 0.0;
  for(float i = 1.0; i < 8.0; i++) {
    wave += sin(uv.x * 10.0 * i * u_scale + t * i * 0.5 + sin(uv.y * 5.0 * i + t)) / i;
  }
  wave *= u_intensity;
  float y = uv.y + wave * 0.1;
  return palette(y + t * 0.1);
}`)
      },
      cells: {
        name: "Living Cells",
        code: createShader(`
vec2 hash2(vec2 p) {
  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
}
vec3 getColor(vec2 uv) {
  float t = u_time * u_speed;
  vec2 p = uv * u_scale * 3.0;
  vec2 i = floor(p);
  vec2 f = fract(p);
  float minDist = 1.0;
  vec2 minPoint;
  for(int y = -1; y <= 1; y++) {
    for(int x = -1; x <= 1; x++) {
      vec2 neighbor = vec2(float(x), float(y));
      vec2 point = hash2(i + neighbor);
      point = 0.5 + 0.5 * sin(t + 6.2831 * point);
      vec2 diff = neighbor + point - f;
      float dist = length(diff);
      if(dist < minDist) { minDist = dist; minPoint = point; }
    }
  }
  float pattern = minDist * u_intensity * 2.0;
  return palette(pattern + minPoint.x * 0.5 + t * 0.1);
}`)
      }
    };

    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
    `;

    let gl, program, canvas;
    let isPlaying = true;
    let startTime = Date.now();
    let activePreset = 'plasma';
    let activePalette = 'neon';
    let animationId;
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecordingVideo = false;
    let isRecordingGif = false;
    let gifFrames = [];

    const params = {
      intensity: 0.5,
      speed: 0.5,
      scale: 3.0,
      halftone: 0,
      chromatic: 0,
      vortex: 0,
      pixelate: 0,
      glitch: 0,
      scanlines: 0
    };

    const colors = {
      color1: '#FF006E',
      color2: '#8338EC',
      color3: '#3A86FF'
    };

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16) / 255,
        g: parseInt(result[2], 16) / 255,
        b: parseInt(result[3], 16) / 255
      } : { r: 1, g: 1, b: 1 };
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('visible');
      setTimeout(() => toast.classList.remove('visible'), 2000);
    }

    function compileShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error(info);
      }
      return shader;
    }

    function createProgram(gl, fragmentSource) {
      const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
      const prog = gl.createProgram();
      gl.attachShader(prog, vertexShader);
      gl.attachShader(prog, fragmentShader);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    function initGL() {
      canvas = document.getElementById('shaderCanvas');
      gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
      if (!gl) {
        alert('WebGL not supported');
        return;
      }

      const positions = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      updateShaderProgram(shaderPresets[activePreset].code);
    }

    function updateShaderProgram(code) {
      try {
        if (program) gl.deleteProgram(program);
        program = createProgram(gl, code);
        document.getElementById('errorDisplay').classList.remove('visible');
        return true;
      } catch (e) {
        document.getElementById('errorDisplay').textContent = 'Error: ' + e.message;
        document.getElementById('errorDisplay').classList.add('visible');
        return false;
      }
    }

    function render() {
      if (!gl || !program) return;

      const wrapper = document.querySelector('.canvas-wrapper');
      canvas.width = wrapper.clientWidth * window.devicePixelRatio;
      canvas.height = wrapper.clientHeight * window.devicePixelRatio;
      gl.viewport(0, 0, canvas.width, canvas.height);

      gl.useProgram(program);

      const posLoc = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      const time = (Date.now() - startTime) / 1000;

      gl.uniform1f(gl.getUniformLocation(program, 'u_time'), time);
      gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), canvas.width, canvas.height);
      gl.uniform1f(gl.getUniformLocation(program, 'u_intensity'), params.intensity);
      gl.uniform1f(gl.getUniformLocation(program, 'u_speed'), params.speed);
      gl.uniform1f(gl.getUniformLocation(program, 'u_scale'), params.scale);
      gl.uniform1f(gl.getUniformLocation(program, 'u_halftone'), params.halftone);
      gl.uniform1f(gl.getUniformLocation(program, 'u_chromatic'), params.chromatic);
      gl.uniform1f(gl.getUniformLocation(program, 'u_vortex'), params.vortex);
      gl.uniform1f(gl.getUniformLocation(program, 'u_pixelate'), params.pixelate);
      gl.uniform1f(gl.getUniformLocation(program, 'u_glitch'), params.glitch);
      gl.uniform1f(gl.getUniformLocation(program, 'u_scanlines'), params.scanlines);

      const c1 = hexToRgb(colors.color1);
      const c2 = hexToRgb(colors.color2);
      const c3 = hexToRgb(colors.color3);
      gl.uniform3f(gl.getUniformLocation(program, 'u_color1'), c1.r, c1.g, c1.b);
      gl.uniform3f(gl.getUniformLocation(program, 'u_color2'), c2.r, c2.g, c2.b);
      gl.uniform3f(gl.getUniformLocation(program, 'u_color3'), c3.r, c3.g, c3.b);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      if (isPlaying) {
        animationId = requestAnimationFrame(render);
      }
    }

    // Download functions
    function downloadFile(content, filename, type) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadPNG() {
      render();
      const dataURL = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = `shader-${activePreset}-${Date.now()}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      showToast('Screenshot saved');
    }

    function downloadShader() {
      const code = document.getElementById('codeEditor').value;
      downloadFile(code, `shader-${activePreset}.glsl`, 'text/plain');
      showToast('Shader exported');
    }

    function downloadSettings() {
      const settings = {
        preset: activePreset,
        palette: activePalette,
        colors: colors,
        params: params,
        timestamp: new Date().toISOString()
      };
      downloadFile(JSON.stringify(settings, null, 2), `shader-settings-${Date.now()}.json`, 'application/json');
      showToast('Settings exported');
    }

    function startVideoRecording() {
      if (isRecordingVideo) {
        stopVideoRecording();
        return;
      }

      recordedChunks = [];
      const stream = canvas.captureStream(30);
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `shader-${activePreset}-${Date.now()}.webm`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Video saved');
      };

      mediaRecorder.start();
      isRecordingVideo = true;
      document.getElementById('recordingIndicator').classList.add('visible');
      document.getElementById('recordingText').textContent = 'Recording Video...';
      document.getElementById('downloadVideo').textContent = 'Stop Recording';
      showToast('Recording started');
    }

    function stopVideoRecording() {
      if (mediaRecorder && isRecordingVideo) {
        mediaRecorder.stop();
        isRecordingVideo = false;
        document.getElementById('recordingIndicator').classList.remove('visible');
        document.getElementById('downloadVideo').innerHTML = 'Record Video<span class="dropdown-item-desc">Capture as WebM video</span>';
      }
    }

    function startGifRecording() {
      if (isRecordingGif) return;
      
      if (typeof GIF === 'undefined') {
        showToast('GIF library loading...');
        return;
      }

      isRecordingGif = true;
      document.getElementById('recordingIndicator').classList.add('visible');
      document.getElementById('recordingText').textContent = 'Recording GIF... 4s';
      showToast('Recording GIF (4 seconds)');

      const gif = new GIF({
        workers: 2,
        quality: 10,
        width: canvas.width / 2,
        height: canvas.height / 2,
        workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
      });

      let frameCount = 0;
      const totalFrames = 60;
      const frameInterval = setInterval(() => {
        if (frameCount >= totalFrames) {
          clearInterval(frameInterval);
          document.getElementById('recordingText').textContent = 'Processing GIF...';
          gif.render();
          return;
        }

        // Create a smaller canvas for GIF
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width / 2;
        tempCanvas.height = canvas.height / 2;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
        gif.addFrame(tempCanvas, { delay: 66, copy: true });
        
        frameCount++;
        const remaining = Math.ceil((totalFrames - frameCount) / 15);
        document.getElementById('recordingText').textContent = `Recording GIF... ${remaining}s`;
      }, 66);

      gif.on('finished', (blob) => {
        isRecordingGif = false;
        document.getElementById('recordingIndicator').classList.remove('visible');
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `shader-${activePreset}-${Date.now()}.gif`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('GIF saved');
      });
    }

    function setupEffectsGrid() {
      const grid = document.getElementById('effectsGrid');
      Object.entries(shaderPresets).forEach(([key, preset]) => {
        const btn = document.createElement('button');
        btn.className = 'effect-btn' + (key === activePreset ? ' active' : '');
        btn.textContent = preset.name;
        btn.onclick = () => selectPreset(key);
        grid.appendChild(btn);
      });
    }

    function setupPaletteGrid() {
      const grid = document.getElementById('paletteGrid');
      Object.entries(colorPalettes).forEach(([key, palette]) => {
        const btn = document.createElement('button');
        btn.className = 'palette-btn' + (key === activePalette ? ' active' : '');
        btn.innerHTML = `
          <div class="palette-colors">
            ${palette.colors.map(c => `<div style="background:${c}"></div>`).join('')}
          </div>
          <div class="palette-label">${palette.name}</div>
        `;
        btn.onclick = () => selectPalette(key);
        grid.appendChild(btn);
      });
    }

    function selectPreset(key) {
      activePreset = key;
      document.querySelectorAll('.effect-btn').forEach((btn, i) => {
        btn.classList.toggle('active', Object.keys(shaderPresets)[i] === key);
      });
      const code = shaderPresets[key].code;
      document.getElementById('codeEditor').value = code;
      if (updateShaderProgram(code)) {
        showToast(shaderPresets[key].name);
      }
    }

    function selectPalette(key) {
      activePalette = key;
      const palette = colorPalettes[key];
      colors.color1 = palette.colors[0];
      colors.color2 = palette.colors[1];
      colors.color3 = palette.colors[2];

      document.getElementById('color1').value = colors.color1;
      document.getElementById('color2').value = colors.color2;
      document.getElementById('color3').value = colors.color3;
      document.getElementById('color1Hex').textContent = colors.color1;
      document.getElementById('color2Hex').textContent = colors.color2;
      document.getElementById('color3Hex').textContent = colors.color3;

      document.querySelectorAll('.palette-btn').forEach((btn, i) => {
        btn.classList.toggle('active', Object.keys(colorPalettes)[i] === key);
      });
    }

    function setupControls() {
      document.getElementById('playPauseBtn').onclick = () => {
        isPlaying = !isPlaying;
        document.getElementById('playPauseBtn').textContent = isPlaying ? 'Pause' : 'Play';
        document.getElementById('playPauseBtn').classList.toggle('btn-primary', isPlaying);
        document.getElementById('playPauseBtn').classList.toggle('btn-secondary', !isPlaying);
        if (isPlaying) render();
      };

      document.getElementById('resetBtn').onclick = () => {
        startTime = Date.now();
      };

      // Download dropdown
      const downloadBtn = document.getElementById('downloadBtn');
      const downloadMenu = document.getElementById('downloadMenu');
      
      downloadBtn.onclick = (e) => {
        e.stopPropagation();
        downloadMenu.classList.toggle('open');
      };

      document.addEventListener('click', () => {
        downloadMenu.classList.remove('open');
      });

      document.getElementById('downloadPNG').onclick = downloadPNG;
      document.getElementById('downloadGIF').onclick = startGifRecording;
      document.getElementById('downloadVideo').onclick = startVideoRecording;
      document.getElementById('downloadShader').onclick = downloadShader;
      document.getElementById('downloadSettings').onclick = downloadSettings;

      ['intensity', 'speed', 'scale'].forEach(param => {
        const input = document.getElementById(param);
        const display = document.getElementById(param + 'Value');
        input.oninput = () => {
          params[param] = parseFloat(input.value);
          display.textContent = param === 'scale' ? params[param].toFixed(1) : params[param].toFixed(2);
        };
      });

      ['halftone', 'chromatic', 'vortex', 'pixelate', 'glitch', 'scanlines'].forEach(param => {
        const input = document.getElementById(param);
        const display = document.getElementById(param + 'Value');
        input.oninput = () => {
          params[param] = parseFloat(input.value);
          display.textContent = params[param].toFixed(2);
        };
      });

      ['color1', 'color2', 'color3'].forEach(key => {
        const input = document.getElementById(key);
        const hex = document.getElementById(key + 'Hex');
        input.oninput = () => {
          colors[key] = input.value;
          hex.textContent = input.value;
          document.querySelectorAll('.palette-btn').forEach(btn => btn.classList.remove('active'));
          activePalette = null;
        };
      });

      const codeEditor = document.getElementById('codeEditor');
      const toggleBtn = document.getElementById('toggleCodeBtn');
      const compileBtn = document.getElementById('compileBtn');

      codeEditor.value = shaderPresets[activePreset].code;

      toggleBtn.onclick = () => {
        const visible = codeEditor.classList.toggle('visible');
        compileBtn.classList.toggle('visible', visible);
        toggleBtn.textContent = visible ? 'Hide Editor' : 'Show Editor';
        toggleBtn.classList.toggle('active', visible);
      };

      compileBtn.onclick = () => {
        if (updateShaderProgram(codeEditor.value)) {
          showToast('Shader Compiled');
        }
      };
    }

    window.addEventListener('resize', () => {
      if (!isPlaying) render();
    });

    window.onload = () => {
      setupEffectsGrid();
      setupPaletteGrid();
      setupControls();
      initGL();
      render();
    };
  </script>
</body>
</html>
